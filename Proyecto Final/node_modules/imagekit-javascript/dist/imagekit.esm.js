function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var version = "1.4.1";

var errorMessages = {
  MANDATORY_INITIALIZATION_MISSING: {
    message: "Missing urlEndpoint during SDK initialization",
    help: ""
  },
  INVALID_TRANSFORMATION_POSITION: {
    message: "Invalid transformationPosition parameter",
    help: ""
  },
  PRIVATE_KEY_CLIENT_SIDE: {
    message: "privateKey should not be passed on the client side",
    help: ""
  },
  MISSING_UPLOAD_DATA: {
    message: "Missing data for upload",
    help: ""
  },
  MISSING_UPLOAD_FILE_PARAMETER: {
    message: "Missing file parameter for upload",
    help: ""
  },
  MISSING_UPLOAD_FILENAME_PARAMETER: {
    message: "Missing fileName parameter for upload",
    help: ""
  },
  MISSING_AUTHENTICATION_ENDPOINT: {
    message: "Missing authentication endpoint for upload",
    help: ""
  },
  MISSING_PUBLIC_KEY: {
    message: "Missing public key for upload",
    help: ""
  },
  AUTH_ENDPOINT_TIMEOUT: {
    message: "The authenticationEndpoint you provided timed out in 60 seconds",
    help: ""
  },
  AUTH_ENDPOINT_NETWORK_ERROR: {
    message: "Request to authenticationEndpoint failed due to network error",
    help: ""
  },
  UPLOAD_ENDPOINT_NETWORK_ERROR: {
    message: "Request to ImageKit upload endpoint failed due to network error",
    help: ""
  },
  INVALID_UPLOAD_OPTIONS: {
    message: "Invalid uploadOptions parameter",
    help: ""
  }
};

function respond (isError, response, callback) {
  if (typeof callback == "function") {
    if (isError) {
      callback(response, null);
    } else {
      callback(null, response);
    }
  }
}

var request = function request(formData, options, callback) {
  generateSignatureToken(options, function (err, signaturObj) {
    if (err) {
      return respond(true, err, callback);
    } else {
      formData.append("signature", (signaturObj === null || signaturObj === void 0 ? void 0 : signaturObj.signature) || "");
      formData.append("expire", String((signaturObj === null || signaturObj === void 0 ? void 0 : signaturObj.expire) || 0));
      formData.append("token", (signaturObj === null || signaturObj === void 0 ? void 0 : signaturObj.token) || "");
      uploadFile(formData, function (err, responseSucessText) {
        if (err) {
          return respond(true, err, callback);
        }
        return respond(false, responseSucessText, callback);
      });
    }
  });
};
var generateSignatureToken = function generateSignatureToken(options, callback) {
  var xhr = new XMLHttpRequest();
  xhr.timeout = 60000;
  xhr.open('GET', options.authenticationEndpoint);
  xhr.ontimeout = function (e) {
    respond(true, errorMessages.AUTH_ENDPOINT_TIMEOUT, callback);
  };
  xhr.onerror = function () {
    respond(true, errorMessages.AUTH_ENDPOINT_NETWORK_ERROR, callback);
  };
  xhr.onload = function () {
    if (xhr.status === 200) {
      try {
        var body = JSON.parse(xhr.responseText);
        var obj = {
          signature: body.signature,
          expire: body.expire,
          token: body.token
        };
        respond(false, obj, callback);
      } catch (ex) {
        respond(true, ex, callback);
      }
    } else {
      try {
        var error = JSON.parse(xhr.responseText);
        respond(true, error, callback);
      } catch (ex) {
        respond(true, ex, callback);
      }
    }
  };
  xhr.send();
  return;
};
var uploadFile = function uploadFile(formData, callback) {
  var uploadFileXHR = new XMLHttpRequest();
  uploadFileXHR.open('POST', 'https://upload.imagekit.io/api/v1/files/upload');
  uploadFileXHR.onerror = function () {
    respond(true, errorMessages.UPLOAD_ENDPOINT_NETWORK_ERROR, callback);
    return;
  };
  uploadFileXHR.onload = function () {
    if (uploadFileXHR.status === 200) {
      var uploadResponse = JSON.parse(uploadFileXHR.responseText);
      callback(null, uploadResponse);
    } else if (uploadFileXHR.status !== 200) {
      try {
        callback(JSON.parse(uploadFileXHR.responseText), null);
      } catch (ex) {
        callback(ex, null);
      }
    }
  };
  uploadFileXHR.send(formData);
  return;
};

var upload = function upload(uploadOptions, options, callback) {
  if (!uploadOptions) {
    respond(true, errorMessages.INVALID_UPLOAD_OPTIONS, callback);
    return;
  }
  if (!uploadOptions.file) {
    respond(true, errorMessages.MISSING_UPLOAD_FILE_PARAMETER, callback);
    return;
  }
  if (!uploadOptions.fileName) {
    respond(true, errorMessages.MISSING_UPLOAD_FILENAME_PARAMETER, callback);
    return;
  }
  if (!options.authenticationEndpoint) {
    respond(true, errorMessages.MISSING_AUTHENTICATION_ENDPOINT, callback);
    return;
  }
  if (!options.publicKey) {
    respond(true, errorMessages.MISSING_PUBLIC_KEY, callback);
    return;
  }
  var formData = new FormData();
  var i;
  for (i in uploadOptions) {
    var param = uploadOptions[i];
    if (typeof param !== "undefined") {
      if (typeof param === "string" || typeof param === "boolean") {
        formData.append(i, String(param));
      } else {
        formData.append(i, param);
      }
    }
  }
  formData.append("publicKey", options.publicKey);
  request(formData, _objectSpread2(_objectSpread2({}, options), {}, {
    authenticationEndpoint: options.authenticationEndpoint
  }), callback);
};

var supportedTransforms = {
  width: "w",
  height: "h",
  aspectRatio: "ar",
  quality: "q",
  crop: "c",
  cropMode: "cm",
  focus: "fo",
  x: "x",
  y: "y",
  format: "f",
  radius: "r",
  background: "bg",
  border: "b",
  rotation: "rt",
  rotate: "rt",
  blur: "bl",
  named: "n",
  overlayImage: "oi",
  overlayImageAspectRatio: "oiar",
  overlayImageBackground: "oibg",
  overlayImageBorder: "oib",
  overlayImageDPR: "oidpr",
  overlayImageQuality: "oiq",
  overlayImageCropping: "oic",
  overlayImageTrim: "oit",
  overlayX: "ox",
  overlayY: "oy",
  overlayFocus: "ofo",
  overlayHeight: "oh",
  overlayWidth: "ow",
  overlayText: "ot",
  overlayTextFontSize: "ots",
  overlayTextFontFamily: "otf",
  overlayTextColor: "otc",
  overlayTextTransparency: "oa",
  overlayAlpha: "oa",
  overlayTextTypography: "ott",
  overlayBackground: "obg",
  overlayTextEncoded: "ote",
  overlayTextWidth: "otw",
  overlayTextBackground: "otbg",
  overlayTextPadding: "otp",
  overlayTextInnerAlignment: "otia",
  overlayRadius: "or",
  progressive: "pr",
  lossless: "lo",
  trim: "t",
  metadata: "md",
  colorProfile: "cp",
  defaultImage: "di",
  dpr: "dpr",
  effectSharpen: "e-sharpen",
  effectUSM: "e-usm",
  effectContrast: "e-contrast",
  effectGray: "e-grayscale",
  original: "orig"
};

var DEFAULT_TRANSFORMATION_POSITION = "path";
var QUERY_TRANSFORMATION_POSITION = "query";
var VALID_TRANSFORMATION_POSITIONS = [DEFAULT_TRANSFORMATION_POSITION, QUERY_TRANSFORMATION_POSITION];
var CHAIN_TRANSFORM_DELIMITER = ":";
var TRANSFORM_DELIMITER = ",";
var TRANSFORM_KEY_VALUE_DELIMITER = "-";
var transformationUtils = {
  getDefault: function getDefault() {
    return DEFAULT_TRANSFORMATION_POSITION;
  },
  addAsQueryParameter: function addAsQueryParameter(options) {
    return options.transformationPosition === QUERY_TRANSFORMATION_POSITION;
  },
  validParameters: function validParameters(options) {
    if (typeof options.transformationPosition == "undefined") return false;
    return VALID_TRANSFORMATION_POSITIONS.indexOf(options.transformationPosition) != -1;
  },
  getTransformKey: function getTransformKey(transform) {
    if (!transform) {
      return "";
    }
    return supportedTransforms[transform] || supportedTransforms[transform.toLowerCase()] || "";
  },
  getChainTransformDelimiter: function getChainTransformDelimiter() {
    return CHAIN_TRANSFORM_DELIMITER;
  },
  getTransformDelimiter: function getTransformDelimiter() {
    return TRANSFORM_DELIMITER;
  },
  getTransformKeyValueDelimiter: function getTransformKeyValueDelimiter() {
    return TRANSFORM_KEY_VALUE_DELIMITER;
  }
};

var TRANSFORMATION_PARAMETER = "tr";
function removeTrailingSlash(str) {
  if (typeof str == "string" && str[str.length - 1] == "/") {
    str = str.substring(0, str.length - 1);
  }
  return str;
}
function removeLeadingSlash(str) {
  if (typeof str == "string" && str[0] == "/") {
    str = str.slice(1);
  }
  return str;
}
function pathJoin(parts, sep) {
  var separator = sep || "/";
  var replace = new RegExp(separator + "{1,}", "g");
  return parts.join(separator).replace(replace, separator);
}
var buildURL = function buildURL(opts) {
  if (!opts.path && !opts.src) {
    return "";
  }
  var urlObj, isSrcParameterUsedForURL, urlEndpointPattern;
  try {
    if (opts.path) {
      urlEndpointPattern = new URL(opts.urlEndpoint).pathname;
      urlObj = new URL(pathJoin([opts.urlEndpoint.replace(urlEndpointPattern, ""), opts.path]));
    } else {
      urlObj = new URL(opts.src);
      isSrcParameterUsedForURL = true;
    }
  } catch (e) {
    console.error(e);
    return "";
  }
  if (opts.sdkVersion && opts.sdkVersion.trim() != "") {
    urlObj.searchParams.append("ik-sdk-version", opts.sdkVersion.trim());
  }
  for (var i in opts.queryParameters) {
    urlObj.searchParams.append(i, String(opts.queryParameters[i]));
  }
  var transformationString = constructTransformationString(opts.transformation);
  if (transformationString && transformationString.length) {
    if (transformationUtils.addAsQueryParameter(opts) || isSrcParameterUsedForURL) {
      urlObj.searchParams.append(TRANSFORMATION_PARAMETER, transformationString);
    } else {
      urlObj.pathname = pathJoin([TRANSFORMATION_PARAMETER + transformationUtils.getChainTransformDelimiter() + transformationString, urlObj.pathname]);
    }
  }
  if (urlEndpointPattern) {
    urlObj.pathname = pathJoin([urlEndpointPattern, urlObj.pathname]);
  } else {
    urlObj.pathname = pathJoin([urlObj.pathname]);
  }
  return urlObj.href;
};
function constructTransformationString(transformation) {
  if (!Array.isArray(transformation)) {
    return "";
  }
  var parsedTransforms = [];
  for (var i = 0, l = transformation.length; i < l; i++) {
    var parsedTransformStep = [];
    for (var key in transformation[i]) {
      var transformKey = transformationUtils.getTransformKey(key);
      if (!transformKey) {
        transformKey = key;
      }
      if (transformation[i][key] === "-") {
        parsedTransformStep.push(transformKey);
      } else {
        var value = transformation[i][key];
        if (transformKey === "oi" || transformKey === "di") {
          value = removeTrailingSlash(removeLeadingSlash(value || ""));
          value = value.replace(/\//g, "@@");
        }
        parsedTransformStep.push([transformKey, value].join(transformationUtils.getTransformKeyValueDelimiter()));
      }
    }
    parsedTransforms.push(parsedTransformStep.join(transformationUtils.getTransformDelimiter()));
  }
  return parsedTransforms.join(transformationUtils.getChainTransformDelimiter());
}

var url = function url(urlOpts, defaultOptions) {
  return buildURL(_objectSpread2(_objectSpread2({}, defaultOptions), urlOpts));
};

function mandatoryParametersAvailable(options) {
  return options.urlEndpoint;
}
function privateKeyPassed(options) {
  return typeof options.privateKey != "undefined";
}
var ImageKit = function () {
  function ImageKit(opts) {
    _classCallCheck(this, ImageKit);
    _defineProperty(this, "options", {
      sdkVersion: "javascript-".concat(version),
      publicKey: "",
      urlEndpoint: "",
      transformationPosition: transformationUtils.getDefault()
    });
    this.options = _objectSpread2(_objectSpread2({}, this.options), opts || {});
    if (!mandatoryParametersAvailable(this.options)) {
      throw errorMessages.MANDATORY_INITIALIZATION_MISSING;
    }
    if (privateKeyPassed(this.options)) {
      throw errorMessages.PRIVATE_KEY_CLIENT_SIDE;
    }
    if (!transformationUtils.validParameters(this.options)) {
      throw errorMessages.INVALID_TRANSFORMATION_POSITION;
    }
  }
  _createClass(ImageKit, [{
    key: "url",
    value: function url$1(urlOptions) {
      return url(urlOptions, this.options);
    }
  }, {
    key: "upload",
    value: function upload$1(uploadOptions, callback, options) {
      var mergedOptions = _objectSpread2(_objectSpread2({}, this.options), options);
      return upload(uploadOptions, mergedOptions, callback);
    }
  }]);
  return ImageKit;
}();

export default ImageKit;
