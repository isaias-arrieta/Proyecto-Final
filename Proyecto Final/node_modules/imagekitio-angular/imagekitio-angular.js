import { Component, ElementRef, EventEmitter, Injectable, Input, NgModule, Output } from '@angular/core';

// import ImageKit from "imagekit-javascript";
const ImageKit = require("imagekit-javascript");
// When SDK is built and packed, the path of this file changes, hence static path cannot work
// const pjson = require("../../package.json");
const SDK_VERSION = '1.0.2';
class ImageKitConfiguration {
}
class ImagekitService {
    /**
     * @param {?} configuration
     */
    constructor(configuration) {
        this.configuration = configuration;
        configuration.sdkVersion = `angular-${SDK_VERSION}`, this._ikInstance = new ImageKit(this.configuration);
    }
    /**
     * @return {?}
     */
    get ikInstance() {
        return this._ikInstance;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    getUrl(config) {
        const /** @type {?} */ url = this._ikInstance.url(config);
        return url;
    }
}
ImagekitService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ImagekitService.ctorParameters = () => [
    { type: ImageKitConfiguration, },
];

class IkImageComponent {
    /**
     * @param {?} el
     * @param {?} imagekit
     */
    constructor(el, imagekit) {
        this.el = el;
        this.imagekit = imagekit;
        this.transformation = [];
        this.url = '';
        this.lqipUrl = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setUrl(this.src, this.path, this.transformation, this.lqip, this.urlEndpoint, this.transformationPosition, this.queryParameters);
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.ngOnInit();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        const /** @type {?} */ that = this;
        this.loadImage(this.lqip && this.lqip.active ? this.lqipUrl : this.url);
        const /** @type {?} */ imageObserver = new IntersectionObserver(function (entry, observer) {
            if (entry[0] && entry[0].isIntersecting) {
                let /** @type {?} */ image = entry[0].target;
                that.loadImage(that.url);
                imageObserver.unobserve(image);
            }
        });
        imageObserver.observe(this.el.nativeElement);
    }
    /**
     * @param {?=} src
     * @param {?=} path
     * @param {?=} transformation
     * @param {?=} lqip
     * @param {?=} urlEndpoint
     * @param {?=} transformationPosition
     * @param {?=} queryParameters
     * @return {?}
     */
    setUrl(src, path, transformation, lqip, urlEndpoint, transformationPosition, queryParameters) {
        const /** @type {?} */ config = this.getConfigObject(src, path, transformation, transformationPosition, urlEndpoint, queryParameters);
        this.url = this.imagekit.getUrl(config);
        if (lqip && lqip.active === true) {
            this.lqipUrl = this.lqipload(lqip.quality, this.url, this.path);
        }
    }
    /**
     * @param {?=} src
     * @param {?=} path
     * @param {?=} transformation
     * @param {?=} transformationPosition
     * @param {?=} urlEndpoint
     * @param {?=} queryParameters
     * @return {?}
     */
    getConfigObject(src, path, transformation, transformationPosition, urlEndpoint, queryParameters) {
        const /** @type {?} */ config = {
            transformation: transformation,
        };
        if (urlEndpoint) {
            config['urlEndpoint'] = urlEndpoint;
        }
        if (queryParameters) {
            config['queryParameters'] = queryParameters;
        }
        if (src) {
            config['src'] = src;
            config['transformationPosition'] = 'query';
        }
        else if (path) {
            config['path'] = path;
            if (transformationPosition) {
                config['transformationPosition'] = transformationPosition;
            }
        }
        else {
            throw new Error('Missing src / path during initialization!');
        }
        return config;
    }
    /**
     * @param {?} url
     * @return {?}
     */
    loadImage(url) {
        const /** @type {?} */ nativeElement = this.el.nativeElement;
        const /** @type {?} */ attributes = nativeElement.attributes;
        const /** @type {?} */ attrsToSet = this.namedNodeMapToObject(attributes);
        attrsToSet['src'] = url;
        const /** @type {?} */ image = nativeElement.children[0];
        this.setElementAttributes(image, attrsToSet);
    }
    /**
     * @param {?} source
     * @return {?}
     */
    namedNodeMapToObject(source) {
        let /** @type {?} */ target = {};
        Object.keys(source).forEach(index => {
            const /** @type {?} */ name = source[index].name;
            const /** @type {?} */ value = source[index].value;
            target[name] = value;
        });
        return target;
    }
    ;
    /**
     * @param {?} quality
     * @param {?} url
     * @param {?} path
     * @return {?}
     */
    lqipload(quality, url, path) {
        let /** @type {?} */ lqip = "";
        if (path) {
            let /** @type {?} */ newUrl = url.split("tr:");
            if (newUrl[0] === url) {
                let /** @type {?} */ temp = url.split("/");
                lqip = `${temp[0]}//${temp[2]}/${temp[3]}/tr:q-${quality}/${temp[4]}`;
            }
            else {
                lqip = `${newUrl[0]}tr:q-${quality}${newUrl[1]}`;
            }
        }
        else {
            lqip = `${url}?tr=q-${quality}`;
        }
        return lqip;
    }
    /**
     * @param {?} element
     * @param {?} attributesLiteral
     * @return {?}
     */
    setElementAttributes(element, attributesLiteral) {
        Object.keys(attributesLiteral).forEach(attrName => {
            element.setAttribute(attrName, attributesLiteral[attrName]);
        });
    }
}
IkImageComponent.decorators = [
    { type: Component, args: [{
                selector: 'ik-image',
                template: `<img src={{src}}>`,
            },] },
];
/**
 * @nocollapse
 */
IkImageComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: ImagekitService, },
];
IkImageComponent.propDecorators = {
    'src': [{ type: Input, args: ['src',] },],
    'path': [{ type: Input, args: ['path',] },],
    'urlEndpoint': [{ type: Input, args: ['urlEndpoint',] },],
    'transformation': [{ type: Input, args: ['transformation',] },],
    'transformationPosition': [{ type: Input, args: ['transformationPosition',] },],
    'queryParameters': [{ type: Input, args: ['queryParameters',] },],
    'lqip': [{ type: Input, args: ['lqip',] },],
};

class IkUploadComponent {
    /**
     * @param {?} imagekit
     */
    constructor(imagekit) {
        this.imagekit = imagekit;
        this.onError = new EventEmitter();
        this.onSuccess = new EventEmitter();
        this.fileToUpload = null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} e
     * @return {?}
     */
    handleFileInput(e) {
        const /** @type {?} */ onError = this.onError;
        const /** @type {?} */ onSuccess = this.onSuccess;
        const /** @type {?} */ files = e.target.files;
        this.fileToUpload = files.item(0);
        if (this.onFileInput) {
            this.onFileInput(e);
            return;
        }
        const /** @type {?} */ params = this.getUploadParams(this.fileToUpload, this.fileName, this.useUniqueFileName, this.tags, this.folder, this.isPrivateFile, this.customCoordinates, this.responseFields);
        const /** @type {?} */ ik = this.imagekit.ikInstance;
        ik.upload(params, function (err, result) {
            if (err) {
                onError.emit(err);
            }
            else {
                onSuccess.emit(result);
            }
        });
    }
    /**
     * @param {?} file
     * @param {?} fileName
     * @param {?=} useUniqueFileName
     * @param {?=} tags
     * @param {?=} folder
     * @param {?=} isPrivateFile
     * @param {?=} customCoordinates
     * @param {?=} responseFields
     * @return {?}
     */
    getUploadParams(file, fileName, useUniqueFileName, tags, folder, isPrivateFile, customCoordinates, responseFields) {
        const /** @type {?} */ params = {
            file: file,
            fileName: fileName,
        };
        if (useUniqueFileName !== undefined) {
            Object.assign(params, { useUniqueFileName: useUniqueFileName });
        }
        if (folder !== undefined) {
            Object.assign(params, { folder: folder });
        }
        if (isPrivateFile !== undefined) {
            Object.assign(params, { isPrivateFile: isPrivateFile });
        }
        if (tags !== undefined) {
            Object.assign(params, { tags: tags });
        }
        if (customCoordinates !== undefined) {
            Object.assign(params, { customCoordinates: customCoordinates });
        }
        if (responseFields !== undefined) {
            Object.assign(params, { responseFields: responseFields });
        }
        return params;
    }
}
IkUploadComponent.decorators = [
    { type: Component, args: [{
                selector: 'ik-upload',
                template: `<input type="file" (change)="handleFileInput($event)" />`,
                providers: [ImagekitService]
            },] },
];
/**
 * @nocollapse
 */
IkUploadComponent.ctorParameters = () => [
    { type: ImagekitService, },
];
IkUploadComponent.propDecorators = {
    'fileName': [{ type: Input, args: ['fileName',] },],
    'useUniqueFileName': [{ type: Input, args: ['useUniqueFileName',] },],
    'tags': [{ type: Input, args: ['tags',] },],
    'folder': [{ type: Input, args: ['folder',] },],
    'isPrivateFile': [{ type: Input, args: ['isPrivateFile',] },],
    'customCoordinates': [{ type: Input, args: ['customCoordinates',] },],
    'responseFields': [{ type: Input, args: ['responseFields',] },],
    'onError': [{ type: Output },],
    'onSuccess': [{ type: Output },],
    'onFileInput': [{ type: Input },],
};

class ImagekitioAngularModule {
    /**
     * @param {?} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: ImagekitioAngularModule,
            providers: [
                { provide: ImageKitConfiguration, useValue: config }
            ]
        };
    }
}
ImagekitioAngularModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IkUploadComponent, IkImageComponent],
                imports: [],
                exports: [IkUploadComponent, IkImageComponent],
                providers: [ImagekitService]
            },] },
];
/**
 * @nocollapse
 */
ImagekitioAngularModule.ctorParameters = () => [];

/*
 * Public API Surface of imagekitio-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { IkImageComponent, IkUploadComponent, ImagekitioAngularModule, ImageKitConfiguration as ɵa, ImagekitService as ɵb };
//# sourceMappingURL=imagekitio-angular.js.map
